; ModuleID = 'Grouper'
source_filename = "Grouper"

@eq = global i1 (i32, i32)* @eq.fun
@pl = global i32 (i32, i32)* @pl.fun
@neg = global i32 (i32)* @neg.fun
@times = global i32 (i32, i32)* @times.fun
@inv = global i32 (i32)* @inv.fun
@pow.0 = global i32 (i32, i32)* @pow.0.fun
@poly_reduce.0 = global { i8*, i8* }* ({ i8*, i8* }*, i32)* @poly_reduce.0.fun
@poly_deg.0 = global i32 ({ i8*, i8* }*)* @poly_deg.0.fun
@poly_eval.0 = global i32 ({ i8*, i8* }*, i32)* @poly_eval.0.fun
@poly_equals.0 = global i1 ({ i8*, i8* }*, { i8*, i8* }*)* @poly_equals.0.fun
@poly_neg.0 = global { i8*, i8* }* ({ i8*, i8* }*)* @poly_neg.0.fun
@poly_plus_inner.0 = global { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*)* @poly_plus_inner.0.fun
@poly_plus.0 = global { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* @poly_plus.0.fun
@co_mul.0 = global { i8*, i8* }* (i32, i32, { i8*, i8* }*, i32)* @co_mul.0.fun
@poly_times.0 = global { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* @poly_times.0.fun
@build_term.0 = global { i8*, i8* }* (i32, i32)* @build_term.0.fun
@poly_div_inner.0 = global { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* @poly_div_inner.0.fun
@f.16 = global i32 (i32, i32)* @f.16.fun
@f.17 = global { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* @f.17.fun
@poly_div.0 = global { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* @poly_div.0.fun
@poly_mod.0 = global { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* @poly_mod.0.fun
@f.20 = global i32 (i32, i32)* @f.20.fun
@f.21 = global { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* @f.21.fun
@poly_gcd.0 = global { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* @poly_gcd.0.fun
@f.24 = global i32 (i32, i32)* @f.24.fun
@f.25 = global i32 (i32, i32)* @f.25.fun
@f.26 = global { i8*, i8* }* ({ i8*, i8* }*)* @f.26.fun
@f.27 = global { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* @f.27.fun
@fmt = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@fmt.1 = private unnamed_addr constant [4 x i8] c"%g\0A\00", align 1
@fmt.2 = private unnamed_addr constant [5 x i8] c"b%d\0A\00", align 1

declare i32 @printf(i8*, ...)

declare void @exit(i32)

define i1 @eq.fun(i32 %0, i32 %1) {
entry:
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = alloca i32, align 4
  store i32 %1, i32* %3, align 4
  %x = load i32, i32* %2, align 4
  %4 = srem i32 %x, 3
  %y = load i32, i32* %3, align 4
  %5 = srem i32 %y, 3
  %6 = icmp eq i32 %4, %5
  ret i1 %6
}

define i32 @pl.fun(i32 %0, i32 %1) {
entry:
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = alloca i32, align 4
  store i32 %1, i32* %3, align 4
  %x = load i32, i32* %2, align 4
  %y = load i32, i32* %3, align 4
  %4 = add i32 %x, %y
  %5 = srem i32 %4, 3
  ret i32 %5
}

define i32 @neg.fun(i32 %0) {
entry:
  %1 = alloca i32, align 4
  store i32 %0, i32* %1, align 4
  %x = load i32, i32* %1, align 4
  %2 = sub i32 0, %x
  %3 = add i32 %2, 3
  ret i32 %3
}

define i32 @times.fun(i32 %0, i32 %1) {
entry:
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = alloca i32, align 4
  store i32 %1, i32* %3, align 4
  %x = load i32, i32* %2, align 4
  %y = load i32, i32* %3, align 4
  %4 = mul i32 %x, %y
  %5 = srem i32 %4, 3
  ret i32 %5
}

define i32 @inv.fun(i32 %0) {
entry:
  %1 = alloca i32, align 4
  store i32 %0, i32* %1, align 4
  %x = load i32, i32* %1, align 4
  ret i32 %x
}

define i32 @pow.0.fun(i32 %0, i32 %1) {
entry:
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = alloca i32, align 4
  store i32 %1, i32* %3, align 4
  %exp = load i32, i32* %3, align 4
  %4 = icmp eq i32 %exp, 1
  br i1 %4, label %then, label %else

then:                                             ; preds = %entry
  %base = load i32, i32* %2, align 4
  br label %ifcont

else:                                             ; preds = %entry
  %times = load i32 (i32, i32)*, i32 (i32, i32)** @times, align 8
  %base1 = load i32, i32* %2, align 4
  %pow.0 = load i32 (i32, i32)*, i32 (i32, i32)** @pow.0, align 8
  %base2 = load i32, i32* %2, align 4
  %exp3 = load i32, i32* %3, align 4
  %5 = sub i32 %exp3, 1
  %6 = call i32 %pow.0(i32 %base2, i32 %5)
  %7 = call i32 %times(i32 %base1, i32 %6)
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  %iftmp = phi i32 [ %base, %then ], [ %7, %else ]
  ret i32 %iftmp
}

define { i8*, i8* }* @poly_reduce.0.fun({ i8*, i8* }* %0, i32 %1) {
entry:
  %2 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %2, align 8
  %3 = alloca i32, align 4
  store i32 %1, i32* %3, align 4
  %xs = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %4 = icmp eq { i8*, i8* }* %xs, null
  br i1 %4, label %then, label %else

then:                                             ; preds = %entry
  %zero = load i32, i32* %3, align 4
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons2 = bitcast i8* %malloccall to { i8*, i8* }*
  %Data_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 0
  %Next_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 1
  %Data_c = bitcast i8** %Data_p to i32**
  %malloccall1 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr = bitcast i8* %malloccall1 to i32*
  store i32 %zero, i32* %D_ptr, align 4
  store i32* %D_ptr, i32** %Data_c, align 8
  %Next_c = bitcast i8** %Next_p to { i8*, i8* }**
  store { i8*, i8* }* null, { i8*, i8* }** %Next_c, align 8
  br label %ifcont12

else:                                             ; preds = %entry
  %eq = load i1 (i32, i32)*, i1 (i32, i32)** @eq, align 8
  %xs2 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.car = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs2, i32 0, i32 0
  %Data = load i8*, i8** %List.car, align 8
  %Data_c3 = bitcast i8* %Data to i32*
  %Data4 = load i32, i32* %Data_c3, align 4
  %zero5 = load i32, i32* %3, align 4
  %5 = call i1 %eq(i32 %Data4, i32 %zero5)
  br i1 %5, label %then6, label %else10

then6:                                            ; preds = %else
  %poly_reduce.0 = load { i8*, i8* }* ({ i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, i32)** @poly_reduce.0, align 8
  %xs7 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.cdr = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs7, i32 0, i32 1
  %Next = load i8*, i8** %List.cdr, align 8
  %Next_c8 = bitcast i8* %Next to { i8*, i8* }*
  %zero9 = load i32, i32* %3, align 4
  %6 = call { i8*, i8* }* %poly_reduce.0({ i8*, i8* }* %Next_c8, i32 %zero9)
  br label %ifcont

else10:                                           ; preds = %else
  %xs11 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  br label %ifcont

ifcont:                                           ; preds = %else10, %then6
  %iftmp = phi { i8*, i8* }* [ %6, %then6 ], [ %xs11, %else10 ]
  br label %ifcont12

ifcont12:                                         ; preds = %ifcont, %then
  %iftmp13 = phi { i8*, i8* }* [ %Cons2, %then ], [ %iftmp, %ifcont ]
  ret { i8*, i8* }* %iftmp13
}

define i32 @poly_deg.0.fun({ i8*, i8* }* %0) {
entry:
  %1 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %1, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %1, align 8
  %2 = icmp eq { i8*, i8* }* %xs, null
  br i1 %2, label %then, label %else

then:                                             ; preds = %entry
  br label %ifcont

else:                                             ; preds = %entry
  %poly_deg.0 = load i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)** @poly_deg.0, align 8
  %xs1 = load { i8*, i8* }*, { i8*, i8* }** %1, align 8
  %List.cdr = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs1, i32 0, i32 1
  %Next = load i8*, i8** %List.cdr, align 8
  %Next_c = bitcast i8* %Next to { i8*, i8* }*
  %3 = call i32 %poly_deg.0({ i8*, i8* }* %Next_c)
  %4 = add i32 1, %3
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  %iftmp = phi i32 [ -1, %then ], [ %4, %else ]
  ret i32 %iftmp
}

define i32 @poly_eval.0.fun({ i8*, i8* }* %0, i32 %1) {
entry:
  %2 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %2, align 8
  %3 = alloca i32, align 4
  store i32 %1, i32* %3, align 4
  %ps = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %4 = icmp eq { i8*, i8* }* %ps, null
  br i1 %4, label %then, label %else

then:                                             ; preds = %entry
  %x = load i32, i32* %3, align 4
  br label %ifcont18

else:                                             ; preds = %entry
  %ps1 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.cdr = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ps1, i32 0, i32 1
  %Next = load i8*, i8** %List.cdr, align 8
  %Next_c = bitcast i8* %Next to { i8*, i8* }*
  %5 = icmp eq { i8*, i8* }* %Next_c, null
  br i1 %5, label %then2, label %else5

then2:                                            ; preds = %else
  %ps3 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.car = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ps3, i32 0, i32 0
  %Data = load i8*, i8** %List.car, align 8
  %Data_c = bitcast i8* %Data to i32*
  %Data4 = load i32, i32* %Data_c, align 4
  br label %ifcont

else5:                                            ; preds = %else
  %6 = alloca i32, align 4
  %poly_deg.0 = load i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)** @poly_deg.0, align 8
  %ps6 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %7 = call i32 %poly_deg.0({ i8*, i8* }* %ps6)
  store i32 %7, i32* %6, align 4
  %8 = alloca i32, align 4
  %times = load i32 (i32, i32)*, i32 (i32, i32)** @times, align 8
  %ps7 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.car8 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ps7, i32 0, i32 0
  %Data9 = load i8*, i8** %List.car8, align 8
  %Data_c10 = bitcast i8* %Data9 to i32*
  %Data11 = load i32, i32* %Data_c10, align 4
  %pow.0 = load i32 (i32, i32)*, i32 (i32, i32)** @pow.0, align 8
  %x12 = load i32, i32* %3, align 4
  %d = load i32, i32* %6, align 4
  %9 = call i32 %pow.0(i32 %x12, i32 %d)
  %10 = call i32 %times(i32 %Data11, i32 %9)
  store i32 %10, i32* %8, align 4
  %pl = load i32 (i32, i32)*, i32 (i32, i32)** @pl, align 8
  %curr_term = load i32, i32* %8, align 4
  %poly_eval.0 = load i32 ({ i8*, i8* }*, i32)*, i32 ({ i8*, i8* }*, i32)** @poly_eval.0, align 8
  %ps13 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.cdr14 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ps13, i32 0, i32 1
  %Next15 = load i8*, i8** %List.cdr14, align 8
  %Next_c16 = bitcast i8* %Next15 to { i8*, i8* }*
  %x17 = load i32, i32* %3, align 4
  %11 = call i32 %poly_eval.0({ i8*, i8* }* %Next_c16, i32 %x17)
  %12 = call i32 %pl(i32 %curr_term, i32 %11)
  br label %ifcont

ifcont:                                           ; preds = %else5, %then2
  %iftmp = phi i32 [ %Data4, %then2 ], [ %12, %else5 ]
  br label %ifcont18

ifcont18:                                         ; preds = %ifcont, %then
  %iftmp19 = phi i32 [ %x, %then ], [ %iftmp, %ifcont ]
  ret i32 %iftmp19
}

define i1 @poly_equals.0.fun({ i8*, i8* }* %0, { i8*, i8* }* %1) {
entry:
  %2 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %2, align 8
  %3 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %1, { i8*, i8* }** %3, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %4 = icmp eq { i8*, i8* }* %xs, null
  %ys = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %5 = icmp eq { i8*, i8* }* %ys, null
  %6 = and i1 %4, %5
  br i1 %6, label %then, label %else

then:                                             ; preds = %entry
  br label %ifcont17

else:                                             ; preds = %entry
  %xs1 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %7 = icmp eq { i8*, i8* }* %xs1, null
  %ys2 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %8 = icmp eq { i8*, i8* }* %ys2, null
  %9 = or i1 %7, %8
  br i1 %9, label %then3, label %else4

then3:                                            ; preds = %else
  br label %ifcont

else4:                                            ; preds = %else
  %eq = load i1 (i32, i32)*, i1 (i32, i32)** @eq, align 8
  %xs5 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.car = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs5, i32 0, i32 0
  %Data = load i8*, i8** %List.car, align 8
  %Data_c = bitcast i8* %Data to i32*
  %Data6 = load i32, i32* %Data_c, align 4
  %ys7 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %List.car8 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ys7, i32 0, i32 0
  %Data9 = load i8*, i8** %List.car8, align 8
  %Data_c10 = bitcast i8* %Data9 to i32*
  %Data11 = load i32, i32* %Data_c10, align 4
  %10 = call i1 %eq(i32 %Data6, i32 %Data11)
  %poly_equals.0 = load i1 ({ i8*, i8* }*, { i8*, i8* }*)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)** @poly_equals.0, align 8
  %xs12 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.cdr = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs12, i32 0, i32 1
  %Next = load i8*, i8** %List.cdr, align 8
  %Next_c = bitcast i8* %Next to { i8*, i8* }*
  %ys13 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %List.cdr14 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ys13, i32 0, i32 1
  %Next15 = load i8*, i8** %List.cdr14, align 8
  %Next_c16 = bitcast i8* %Next15 to { i8*, i8* }*
  %11 = call i1 %poly_equals.0({ i8*, i8* }* %Next_c, { i8*, i8* }* %Next_c16)
  %12 = and i1 %10, %11
  br label %ifcont

ifcont:                                           ; preds = %else4, %then3
  %iftmp = phi i1 [ false, %then3 ], [ %12, %else4 ]
  br label %ifcont17

ifcont17:                                         ; preds = %ifcont, %then
  %iftmp18 = phi i1 [ true, %then ], [ %iftmp, %ifcont ]
  ret i1 %iftmp18
}

define { i8*, i8* }* @poly_neg.0.fun({ i8*, i8* }* %0) {
entry:
  %1 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %1, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %1, align 8
  %2 = icmp eq { i8*, i8* }* %xs, null
  br i1 %2, label %then, label %else

then:                                             ; preds = %entry
  br label %ifcont

else:                                             ; preds = %entry
  %neg = load i32 (i32)*, i32 (i32)** @neg, align 8
  %xs1 = load { i8*, i8* }*, { i8*, i8* }** %1, align 8
  %List.car = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs1, i32 0, i32 0
  %Data = load i8*, i8** %List.car, align 8
  %Data_c = bitcast i8* %Data to i32*
  %Data2 = load i32, i32* %Data_c, align 4
  %3 = call i32 %neg(i32 %Data2)
  %poly_neg.0 = load { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*)** @poly_neg.0, align 8
  %xs3 = load { i8*, i8* }*, { i8*, i8* }** %1, align 8
  %List.cdr = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs3, i32 0, i32 1
  %Next = load i8*, i8** %List.cdr, align 8
  %Next_c = bitcast i8* %Next to { i8*, i8* }*
  %4 = call { i8*, i8* }* %poly_neg.0({ i8*, i8* }* %Next_c)
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons2 = bitcast i8* %malloccall to { i8*, i8* }*
  %Data_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 0
  %Next_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 1
  %Data_c4 = bitcast i8** %Data_p to i32**
  %malloccall5 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr = bitcast i8* %malloccall5 to i32*
  store i32 %3, i32* %D_ptr, align 4
  store i32* %D_ptr, i32** %Data_c4, align 8
  %Next_c6 = bitcast i8** %Next_p to { i8*, i8* }**
  store { i8*, i8* }* %4, { i8*, i8* }** %Next_c6, align 8
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  %iftmp = phi { i8*, i8* }* [ null, %then ], [ %Cons2, %else ]
  ret { i8*, i8* }* %iftmp
}

define { i8*, i8* }* @poly_plus_inner.0.fun({ i8*, i8* }* %0, { i8*, i8* }* %1) {
entry:
  %2 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %2, align 8
  %3 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %1, { i8*, i8* }** %3, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %4 = icmp eq { i8*, i8* }* %xs, null
  %ys = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %5 = icmp eq { i8*, i8* }* %ys, null
  %6 = and i1 %4, %5
  br i1 %6, label %then, label %else

then:                                             ; preds = %entry
  br label %ifcont65

else:                                             ; preds = %entry
  %7 = alloca i32, align 4
  %poly_deg.0 = load i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)** @poly_deg.0, align 8
  %xs1 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %8 = call i32 %poly_deg.0({ i8*, i8* }* %xs1)
  store i32 %8, i32* %7, align 4
  %9 = alloca i32, align 4
  %poly_deg.02 = load i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)** @poly_deg.0, align 8
  %ys3 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %10 = call i32 %poly_deg.02({ i8*, i8* }* %ys3)
  store i32 %10, i32* %9, align 4
  %x = load i32, i32* %7, align 4
  %y = load i32, i32* %9, align 4
  %11 = icmp slt i32 %x, %y
  br i1 %11, label %then4, label %else12

then4:                                            ; preds = %else
  %ys5 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %List.car = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ys5, i32 0, i32 0
  %Data = load i8*, i8** %List.car, align 8
  %Data_c = bitcast i8* %Data to i32*
  %Data6 = load i32, i32* %Data_c, align 4
  %poly_plus_inner.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*)** @poly_plus_inner.0, align 8
  %xs7 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %ys8 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %List.cdr = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ys8, i32 0, i32 1
  %Next = load i8*, i8** %List.cdr, align 8
  %Next_c = bitcast i8* %Next to { i8*, i8* }*
  %12 = call { i8*, i8* }* %poly_plus_inner.0({ i8*, i8* }* %xs7, { i8*, i8* }* %Next_c)
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons2 = bitcast i8* %malloccall to { i8*, i8* }*
  %Data_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 0
  %Next_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 1
  %Data_c9 = bitcast i8** %Data_p to i32**
  %malloccall10 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr = bitcast i8* %malloccall10 to i32*
  store i32 %Data6, i32* %D_ptr, align 4
  store i32* %D_ptr, i32** %Data_c9, align 8
  %Next_c11 = bitcast i8** %Next_p to { i8*, i8* }**
  store { i8*, i8* }* %12, { i8*, i8* }** %Next_c11, align 8
  br label %ifcont63

else12:                                           ; preds = %else
  %x13 = load i32, i32* %7, align 4
  %y14 = load i32, i32* %9, align 4
  %13 = icmp sgt i32 %x13, %y14
  br i1 %13, label %then15, label %else35

then15:                                           ; preds = %else12
  %xs16 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.car17 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs16, i32 0, i32 0
  %Data18 = load i8*, i8** %List.car17, align 8
  %Data_c19 = bitcast i8* %Data18 to i32*
  %Data20 = load i32, i32* %Data_c19, align 4
  %poly_plus_inner.021 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*)** @poly_plus_inner.0, align 8
  %ys22 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %xs23 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.cdr24 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs23, i32 0, i32 1
  %Next25 = load i8*, i8** %List.cdr24, align 8
  %Next_c26 = bitcast i8* %Next25 to { i8*, i8* }*
  %14 = call { i8*, i8* }* %poly_plus_inner.021({ i8*, i8* }* %ys22, { i8*, i8* }* %Next_c26)
  %malloccall27 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons228 = bitcast i8* %malloccall27 to { i8*, i8* }*
  %Data_p29 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons228, i32 0, i32 0
  %Next_p30 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons228, i32 0, i32 1
  %Data_c31 = bitcast i8** %Data_p29 to i32**
  %malloccall32 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr33 = bitcast i8* %malloccall32 to i32*
  store i32 %Data20, i32* %D_ptr33, align 4
  store i32* %D_ptr33, i32** %Data_c31, align 8
  %Next_c34 = bitcast i8** %Next_p30 to { i8*, i8* }**
  store { i8*, i8* }* %14, { i8*, i8* }** %Next_c34, align 8
  br label %ifcont

else35:                                           ; preds = %else12
  %pl = load i32 (i32, i32)*, i32 (i32, i32)** @pl, align 8
  %xs36 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.car37 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs36, i32 0, i32 0
  %Data38 = load i8*, i8** %List.car37, align 8
  %Data_c39 = bitcast i8* %Data38 to i32*
  %Data40 = load i32, i32* %Data_c39, align 4
  %ys41 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %List.car42 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ys41, i32 0, i32 0
  %Data43 = load i8*, i8** %List.car42, align 8
  %Data_c44 = bitcast i8* %Data43 to i32*
  %Data45 = load i32, i32* %Data_c44, align 4
  %15 = call i32 %pl(i32 %Data40, i32 %Data45)
  %poly_plus_inner.046 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*)** @poly_plus_inner.0, align 8
  %xs47 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %List.cdr48 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs47, i32 0, i32 1
  %Next49 = load i8*, i8** %List.cdr48, align 8
  %Next_c50 = bitcast i8* %Next49 to { i8*, i8* }*
  %ys51 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %List.cdr52 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ys51, i32 0, i32 1
  %Next53 = load i8*, i8** %List.cdr52, align 8
  %Next_c54 = bitcast i8* %Next53 to { i8*, i8* }*
  %16 = call { i8*, i8* }* %poly_plus_inner.046({ i8*, i8* }* %Next_c50, { i8*, i8* }* %Next_c54)
  %malloccall55 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons256 = bitcast i8* %malloccall55 to { i8*, i8* }*
  %Data_p57 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons256, i32 0, i32 0
  %Next_p58 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons256, i32 0, i32 1
  %Data_c59 = bitcast i8** %Data_p57 to i32**
  %malloccall60 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr61 = bitcast i8* %malloccall60 to i32*
  store i32 %15, i32* %D_ptr61, align 4
  store i32* %D_ptr61, i32** %Data_c59, align 8
  %Next_c62 = bitcast i8** %Next_p58 to { i8*, i8* }**
  store { i8*, i8* }* %16, { i8*, i8* }** %Next_c62, align 8
  br label %ifcont

ifcont:                                           ; preds = %else35, %then15
  %iftmp = phi { i8*, i8* }* [ %Cons228, %then15 ], [ %Cons256, %else35 ]
  br label %ifcont63

ifcont63:                                         ; preds = %ifcont, %then4
  %iftmp64 = phi { i8*, i8* }* [ %Cons2, %then4 ], [ %iftmp, %ifcont ]
  br label %ifcont65

ifcont65:                                         ; preds = %ifcont63, %then
  %iftmp66 = phi { i8*, i8* }* [ null, %then ], [ %iftmp64, %ifcont63 ]
  ret { i8*, i8* }* %iftmp66
}

define { i8*, i8* }* @poly_plus.0.fun({ i8*, i8* }* %0, { i8*, i8* }* %1, i32 %2) {
entry:
  %3 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %3, align 8
  %4 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %1, { i8*, i8* }** %4, align 8
  %5 = alloca i32, align 4
  store i32 %2, i32* %5, align 4
  %poly_reduce.0 = load { i8*, i8* }* ({ i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, i32)** @poly_reduce.0, align 8
  %poly_plus_inner.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*)** @poly_plus_inner.0, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %ys = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %6 = call { i8*, i8* }* %poly_plus_inner.0({ i8*, i8* }* %xs, { i8*, i8* }* %ys)
  %zero = load i32, i32* %5, align 4
  %7 = call { i8*, i8* }* %poly_reduce.0({ i8*, i8* }* %6, i32 %zero)
  ret { i8*, i8* }* %7
}

define { i8*, i8* }* @co_mul.0.fun(i32 %0, i32 %1, { i8*, i8* }* %2, i32 %3) {
entry:
  %4 = alloca i32, align 4
  store i32 %0, i32* %4, align 4
  %5 = alloca i32, align 4
  store i32 %1, i32* %5, align 4
  %6 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %2, { i8*, i8* }** %6, align 8
  %7 = alloca i32, align 4
  store i32 %3, i32* %7, align 4
  %xs = load { i8*, i8* }*, { i8*, i8* }** %6, align 8
  %8 = icmp eq { i8*, i8* }* %xs, null
  %degree = load i32, i32* %5, align 4
  %9 = icmp eq i32 %degree, 0
  %10 = and i1 %8, %9
  br i1 %10, label %then, label %else

then:                                             ; preds = %entry
  br label %ifcont26

else:                                             ; preds = %entry
  %xs1 = load { i8*, i8* }*, { i8*, i8* }** %6, align 8
  %11 = icmp eq { i8*, i8* }* %xs1, null
  br i1 %11, label %then2, label %else7

then2:                                            ; preds = %else
  %zero = load i32, i32* %7, align 4
  %co_mul.0 = load { i8*, i8* }* (i32, i32, { i8*, i8* }*, i32)*, { i8*, i8* }* (i32, i32, { i8*, i8* }*, i32)** @co_mul.0, align 8
  %coeff = load i32, i32* %4, align 4
  %degree3 = load i32, i32* %5, align 4
  %12 = sub i32 %degree3, 1
  %xs4 = load { i8*, i8* }*, { i8*, i8* }** %6, align 8
  %zero5 = load i32, i32* %7, align 4
  %13 = call { i8*, i8* }* %co_mul.0(i32 %coeff, i32 %12, { i8*, i8* }* %xs4, i32 %zero5)
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons2 = bitcast i8* %malloccall to { i8*, i8* }*
  %Data_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 0
  %Next_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 1
  %Data_c = bitcast i8** %Data_p to i32**
  %malloccall6 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr = bitcast i8* %malloccall6 to i32*
  store i32 %zero, i32* %D_ptr, align 4
  store i32* %D_ptr, i32** %Data_c, align 8
  %Next_c = bitcast i8** %Next_p to { i8*, i8* }**
  store { i8*, i8* }* %13, { i8*, i8* }** %Next_c, align 8
  br label %ifcont

else7:                                            ; preds = %else
  %times = load i32 (i32, i32)*, i32 (i32, i32)** @times, align 8
  %coeff8 = load i32, i32* %4, align 4
  %xs9 = load { i8*, i8* }*, { i8*, i8* }** %6, align 8
  %List.car = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs9, i32 0, i32 0
  %Data = load i8*, i8** %List.car, align 8
  %Data_c10 = bitcast i8* %Data to i32*
  %Data11 = load i32, i32* %Data_c10, align 4
  %14 = call i32 %times(i32 %coeff8, i32 %Data11)
  %co_mul.012 = load { i8*, i8* }* (i32, i32, { i8*, i8* }*, i32)*, { i8*, i8* }* (i32, i32, { i8*, i8* }*, i32)** @co_mul.0, align 8
  %coeff13 = load i32, i32* %4, align 4
  %degree14 = load i32, i32* %5, align 4
  %xs15 = load { i8*, i8* }*, { i8*, i8* }** %6, align 8
  %List.cdr = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs15, i32 0, i32 1
  %Next = load i8*, i8** %List.cdr, align 8
  %Next_c16 = bitcast i8* %Next to { i8*, i8* }*
  %zero17 = load i32, i32* %7, align 4
  %15 = call { i8*, i8* }* %co_mul.012(i32 %coeff13, i32 %degree14, { i8*, i8* }* %Next_c16, i32 %zero17)
  %malloccall18 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons219 = bitcast i8* %malloccall18 to { i8*, i8* }*
  %Data_p20 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons219, i32 0, i32 0
  %Next_p21 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons219, i32 0, i32 1
  %Data_c22 = bitcast i8** %Data_p20 to i32**
  %malloccall23 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr24 = bitcast i8* %malloccall23 to i32*
  store i32 %14, i32* %D_ptr24, align 4
  store i32* %D_ptr24, i32** %Data_c22, align 8
  %Next_c25 = bitcast i8** %Next_p21 to { i8*, i8* }**
  store { i8*, i8* }* %15, { i8*, i8* }** %Next_c25, align 8
  br label %ifcont

ifcont:                                           ; preds = %else7, %then2
  %iftmp = phi { i8*, i8* }* [ %Cons2, %then2 ], [ %Cons219, %else7 ]
  br label %ifcont26

ifcont26:                                         ; preds = %ifcont, %then
  %iftmp27 = phi { i8*, i8* }* [ null, %then ], [ %iftmp, %ifcont ]
  ret { i8*, i8* }* %iftmp27
}

define { i8*, i8* }* @poly_times.0.fun({ i8*, i8* }* %0, { i8*, i8* }* %1, i32 %2) {
entry:
  %3 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %3, align 8
  %4 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %1, { i8*, i8* }** %4, align 8
  %5 = alloca i32, align 4
  store i32 %2, i32* %5, align 4
  %xs = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %6 = icmp eq { i8*, i8* }* %xs, null
  br i1 %6, label %then, label %else

then:                                             ; preds = %entry
  br label %ifcont

else:                                             ; preds = %entry
  %7 = alloca i32, align 4
  %poly_deg.0 = load i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)** @poly_deg.0, align 8
  %xs1 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %8 = call i32 %poly_deg.0({ i8*, i8* }* %xs1)
  store i32 %8, i32* %7, align 4
  %poly_plus.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_plus.0, align 8
  %co_mul.0 = load { i8*, i8* }* (i32, i32, { i8*, i8* }*, i32)*, { i8*, i8* }* (i32, i32, { i8*, i8* }*, i32)** @co_mul.0, align 8
  %xs2 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %List.car = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs2, i32 0, i32 0
  %Data = load i8*, i8** %List.car, align 8
  %Data_c = bitcast i8* %Data to i32*
  %Data3 = load i32, i32* %Data_c, align 4
  %poly_deg.04 = load i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)** @poly_deg.0, align 8
  %xs5 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %9 = call i32 %poly_deg.04({ i8*, i8* }* %xs5)
  %ys = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %zero = load i32, i32* %5, align 4
  %10 = call { i8*, i8* }* %co_mul.0(i32 %Data3, i32 %9, { i8*, i8* }* %ys, i32 %zero)
  %poly_times.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_times.0, align 8
  %xs6 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %List.cdr = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs6, i32 0, i32 1
  %Next = load i8*, i8** %List.cdr, align 8
  %Next_c = bitcast i8* %Next to { i8*, i8* }*
  %ys7 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %zero8 = load i32, i32* %5, align 4
  %11 = call { i8*, i8* }* %poly_times.0({ i8*, i8* }* %Next_c, { i8*, i8* }* %ys7, i32 %zero8)
  %zero9 = load i32, i32* %5, align 4
  %12 = call { i8*, i8* }* %poly_plus.0({ i8*, i8* }* %10, { i8*, i8* }* %11, i32 %zero9)
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  %iftmp = phi { i8*, i8* }* [ null, %then ], [ %12, %else ]
  ret { i8*, i8* }* %iftmp
}

define { i8*, i8* }* @build_term.0.fun(i32 %0, i32 %1) {
entry:
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = alloca i32, align 4
  store i32 %1, i32* %3, align 4
  %x = load i32, i32* %2, align 4
  %4 = icmp eq i32 %x, 0
  br i1 %4, label %then, label %else

then:                                             ; preds = %entry
  br label %ifcont

else:                                             ; preds = %entry
  %zero = load i32, i32* %3, align 4
  %build_term.0 = load { i8*, i8* }* (i32, i32)*, { i8*, i8* }* (i32, i32)** @build_term.0, align 8
  %x1 = load i32, i32* %2, align 4
  %5 = sub i32 %x1, 1
  %zero2 = load i32, i32* %3, align 4
  %6 = call { i8*, i8* }* %build_term.0(i32 %5, i32 %zero2)
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons2 = bitcast i8* %malloccall to { i8*, i8* }*
  %Data_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 0
  %Next_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 1
  %Data_c = bitcast i8** %Data_p to i32**
  %malloccall3 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr = bitcast i8* %malloccall3 to i32*
  store i32 %zero, i32* %D_ptr, align 4
  store i32* %D_ptr, i32** %Data_c, align 8
  %Next_c = bitcast i8** %Next_p to { i8*, i8* }**
  store { i8*, i8* }* %6, { i8*, i8* }** %Next_c, align 8
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  %iftmp = phi { i8*, i8* }* [ null, %then ], [ %Cons2, %else ]
  ret { i8*, i8* }* %iftmp
}

define { i8*, i8* }* @poly_div_inner.0.fun({ i8*, i8* }* %0, { i8*, i8* }* %1, i32 %2) {
entry:
  %3 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %3, align 8
  %4 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %1, { i8*, i8* }** %4, align 8
  %5 = alloca i32, align 4
  store i32 %2, i32* %5, align 4
  %ys = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %6 = icmp eq { i8*, i8* }* %ys, null
  br i1 %6, label %then, label %else

then:                                             ; preds = %entry
  br label %ifcont41

else:                                             ; preds = %entry
  %7 = alloca i32, align 4
  %poly_deg.0 = load i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)** @poly_deg.0, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %8 = call i32 %poly_deg.0({ i8*, i8* }* %xs)
  store i32 %8, i32* %7, align 4
  %9 = alloca i32, align 4
  %poly_deg.01 = load i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)** @poly_deg.0, align 8
  %ys2 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %10 = call i32 %poly_deg.01({ i8*, i8* }* %ys2)
  store i32 %10, i32* %9, align 4
  %x = load i32, i32* %7, align 4
  %y = load i32, i32* %9, align 4
  %11 = icmp slt i32 %x, %y
  %poly_equals.0 = load i1 ({ i8*, i8* }*, { i8*, i8* }*)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)** @poly_equals.0, align 8
  %xs3 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %zero = load i32, i32* %5, align 4
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons2 = bitcast i8* %malloccall to { i8*, i8* }*
  %Data_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 0
  %Next_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 1
  %Data_c = bitcast i8** %Data_p to i32**
  %malloccall4 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr = bitcast i8* %malloccall4 to i32*
  store i32 %zero, i32* %D_ptr, align 4
  store i32* %D_ptr, i32** %Data_c, align 8
  %Next_c = bitcast i8** %Next_p to { i8*, i8* }**
  store { i8*, i8* }* null, { i8*, i8* }** %Next_c, align 8
  %12 = call i1 %poly_equals.0({ i8*, i8* }* %xs3, { i8*, i8* }* %Cons2)
  %13 = or i1 %11, %12
  br i1 %13, label %then5, label %else6

then5:                                            ; preds = %else
  br label %ifcont

else6:                                            ; preds = %else
  %14 = alloca i32, align 4
  %f.16 = load i32 (i32, i32)*, i32 (i32, i32)** @f.16, align 8
  %xs7 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %List.car = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs7, i32 0, i32 0
  %Data = load i8*, i8** %List.car, align 8
  %Data_c8 = bitcast i8* %Data to i32*
  %Data9 = load i32, i32* %Data_c8, align 4
  %ys10 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %List.car11 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ys10, i32 0, i32 0
  %Data12 = load i8*, i8** %List.car11, align 8
  %Data_c13 = bitcast i8* %Data12 to i32*
  %Data14 = load i32, i32* %Data_c13, align 4
  %15 = call i32 %f.16(i32 %Data9, i32 %Data14)
  store i32 %15, i32* %14, align 4
  %16 = alloca { i8*, i8* }*, align 8
  %lead_coeff = load i32, i32* %14, align 4
  %build_term.0 = load { i8*, i8* }* (i32, i32)*, { i8*, i8* }* (i32, i32)** @build_term.0, align 8
  %x15 = load i32, i32* %7, align 4
  %y16 = load i32, i32* %9, align 4
  %17 = sub i32 %x15, %y16
  %zero17 = load i32, i32* %5, align 4
  %18 = call { i8*, i8* }* %build_term.0(i32 %17, i32 %zero17)
  %malloccall18 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons219 = bitcast i8* %malloccall18 to { i8*, i8* }*
  %Data_p20 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons219, i32 0, i32 0
  %Next_p21 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons219, i32 0, i32 1
  %Data_c22 = bitcast i8** %Data_p20 to i32**
  %malloccall23 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr24 = bitcast i8* %malloccall23 to i32*
  store i32 %lead_coeff, i32* %D_ptr24, align 4
  store i32* %D_ptr24, i32** %Data_c22, align 8
  %Next_c25 = bitcast i8** %Next_p21 to { i8*, i8* }**
  store { i8*, i8* }* %18, { i8*, i8* }** %Next_c25, align 8
  store { i8*, i8* }* %Cons219, { i8*, i8* }** %16, align 8
  %19 = alloca { i8*, i8* }*, align 8
  %f.17 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @f.17, align 8
  %xs26 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %poly_times.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_times.0, align 8
  %lead_term = load { i8*, i8* }*, { i8*, i8* }** %16, align 8
  %ys27 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %zero28 = load i32, i32* %5, align 4
  %20 = call { i8*, i8* }* %poly_times.0({ i8*, i8* }* %lead_term, { i8*, i8* }* %ys27, i32 %zero28)
  %zero29 = load i32, i32* %5, align 4
  %21 = call { i8*, i8* }* %f.17({ i8*, i8* }* %xs26, { i8*, i8* }* %20, i32 %zero29)
  store { i8*, i8* }* %21, { i8*, i8* }** %19, align 8
  %lead_coeff30 = load i32, i32* %14, align 4
  %poly_div_inner.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_div_inner.0, align 8
  %diff = load { i8*, i8* }*, { i8*, i8* }** %19, align 8
  %ys31 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %zero32 = load i32, i32* %5, align 4
  %22 = call { i8*, i8* }* %poly_div_inner.0({ i8*, i8* }* %diff, { i8*, i8* }* %ys31, i32 %zero32)
  %malloccall33 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons234 = bitcast i8* %malloccall33 to { i8*, i8* }*
  %Data_p35 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons234, i32 0, i32 0
  %Next_p36 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons234, i32 0, i32 1
  %Data_c37 = bitcast i8** %Data_p35 to i32**
  %malloccall38 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr39 = bitcast i8* %malloccall38 to i32*
  store i32 %lead_coeff30, i32* %D_ptr39, align 4
  store i32* %D_ptr39, i32** %Data_c37, align 8
  %Next_c40 = bitcast i8** %Next_p36 to { i8*, i8* }**
  store { i8*, i8* }* %22, { i8*, i8* }** %Next_c40, align 8
  br label %ifcont

ifcont:                                           ; preds = %else6, %then5
  %iftmp = phi { i8*, i8* }* [ null, %then5 ], [ %Cons234, %else6 ]
  br label %ifcont41

ifcont41:                                         ; preds = %ifcont, %then
  %iftmp42 = phi { i8*, i8* }* [ null, %then ], [ %iftmp, %ifcont ]
  ret { i8*, i8* }* %iftmp42
}

define i32 @f.16.fun(i32 %0, i32 %1) {
entry:
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = alloca i32, align 4
  store i32 %1, i32* %3, align 4
  %times = load i32 (i32, i32)*, i32 (i32, i32)** @times, align 8
  %x = load i32, i32* %2, align 4
  %inv = load i32 (i32)*, i32 (i32)** @inv, align 8
  %y = load i32, i32* %3, align 4
  %4 = call i32 %inv(i32 %y)
  %5 = call i32 %times(i32 %x, i32 %4)
  ret i32 %5
}

define { i8*, i8* }* @f.17.fun({ i8*, i8* }* %0, { i8*, i8* }* %1, i32 %2) {
entry:
  %3 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %3, align 8
  %4 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %1, { i8*, i8* }** %4, align 8
  %5 = alloca i32, align 4
  store i32 %2, i32* %5, align 4
  %poly_plus.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_plus.0, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %poly_neg.0 = load { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*)** @poly_neg.0, align 8
  %ys = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %6 = call { i8*, i8* }* %poly_neg.0({ i8*, i8* }* %ys)
  %zero = load i32, i32* %5, align 4
  %7 = call { i8*, i8* }* %poly_plus.0({ i8*, i8* }* %xs, { i8*, i8* }* %6, i32 %zero)
  ret { i8*, i8* }* %7
}

define { i8*, i8* }* @poly_div.0.fun({ i8*, i8* }* %0, { i8*, i8* }* %1, i32 %2) {
entry:
  %3 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %3, align 8
  %4 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %1, { i8*, i8* }** %4, align 8
  %5 = alloca i32, align 4
  store i32 %2, i32* %5, align 4
  %6 = alloca { i8*, i8* }*, align 8
  %poly_div_inner.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_div_inner.0, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %ys = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %zero = load i32, i32* %5, align 4
  %7 = call { i8*, i8* }* %poly_div_inner.0({ i8*, i8* }* %xs, { i8*, i8* }* %ys, i32 %zero)
  store { i8*, i8* }* %7, { i8*, i8* }** %6, align 8
  %q = load { i8*, i8* }*, { i8*, i8* }** %6, align 8
  %8 = icmp eq { i8*, i8* }* %q, null
  br i1 %8, label %then, label %else

then:                                             ; preds = %entry
  %zero1 = load i32, i32* %5, align 4
  %q2 = load { i8*, i8* }*, { i8*, i8* }** %6, align 8
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons2 = bitcast i8* %malloccall to { i8*, i8* }*
  %Data_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 0
  %Next_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 1
  %Data_c = bitcast i8** %Data_p to i32**
  %malloccall3 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr = bitcast i8* %malloccall3 to i32*
  store i32 %zero1, i32* %D_ptr, align 4
  store i32* %D_ptr, i32** %Data_c, align 8
  %Next_c = bitcast i8** %Next_p to { i8*, i8* }**
  store { i8*, i8* }* %q2, { i8*, i8* }** %Next_c, align 8
  br label %ifcont

else:                                             ; preds = %entry
  %q4 = load { i8*, i8* }*, { i8*, i8* }** %6, align 8
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  %iftmp = phi { i8*, i8* }* [ %Cons2, %then ], [ %q4, %else ]
  ret { i8*, i8* }* %iftmp
}

define { i8*, i8* }* @poly_mod.0.fun({ i8*, i8* }* %0, { i8*, i8* }* %1, i32 %2) {
entry:
  %3 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %3, align 8
  %4 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %1, { i8*, i8* }** %4, align 8
  %5 = alloca i32, align 4
  store i32 %2, i32* %5, align 4
  %ys = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %6 = icmp eq { i8*, i8* }* %ys, null
  br i1 %6, label %then, label %else

then:                                             ; preds = %entry
  %xs = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  br label %ifcont34

else:                                             ; preds = %entry
  %7 = alloca i32, align 4
  %poly_deg.0 = load i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)** @poly_deg.0, align 8
  %xs1 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %8 = call i32 %poly_deg.0({ i8*, i8* }* %xs1)
  store i32 %8, i32* %7, align 4
  %9 = alloca i32, align 4
  %poly_deg.02 = load i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)** @poly_deg.0, align 8
  %ys3 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %10 = call i32 %poly_deg.02({ i8*, i8* }* %ys3)
  store i32 %10, i32* %9, align 4
  %x = load i32, i32* %7, align 4
  %y = load i32, i32* %9, align 4
  %11 = icmp slt i32 %x, %y
  %poly_equals.0 = load i1 ({ i8*, i8* }*, { i8*, i8* }*)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)** @poly_equals.0, align 8
  %xs4 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %zero = load i32, i32* %5, align 4
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons2 = bitcast i8* %malloccall to { i8*, i8* }*
  %Data_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 0
  %Next_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 1
  %Data_c = bitcast i8** %Data_p to i32**
  %malloccall5 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr = bitcast i8* %malloccall5 to i32*
  store i32 %zero, i32* %D_ptr, align 4
  store i32* %D_ptr, i32** %Data_c, align 8
  %Next_c = bitcast i8** %Next_p to { i8*, i8* }**
  store { i8*, i8* }* null, { i8*, i8* }** %Next_c, align 8
  %12 = call i1 %poly_equals.0({ i8*, i8* }* %xs4, { i8*, i8* }* %Cons2)
  %13 = or i1 %11, %12
  br i1 %13, label %then6, label %else8

then6:                                            ; preds = %else
  %xs7 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  br label %ifcont

else8:                                            ; preds = %else
  %14 = alloca i32, align 4
  %f.20 = load i32 (i32, i32)*, i32 (i32, i32)** @f.20, align 8
  %xs9 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %List.car = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %xs9, i32 0, i32 0
  %Data = load i8*, i8** %List.car, align 8
  %Data_c10 = bitcast i8* %Data to i32*
  %Data11 = load i32, i32* %Data_c10, align 4
  %ys12 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %List.car13 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %ys12, i32 0, i32 0
  %Data14 = load i8*, i8** %List.car13, align 8
  %Data_c15 = bitcast i8* %Data14 to i32*
  %Data16 = load i32, i32* %Data_c15, align 4
  %15 = call i32 %f.20(i32 %Data11, i32 %Data16)
  store i32 %15, i32* %14, align 4
  %16 = alloca { i8*, i8* }*, align 8
  %lead_coeff = load i32, i32* %14, align 4
  %build_term.0 = load { i8*, i8* }* (i32, i32)*, { i8*, i8* }* (i32, i32)** @build_term.0, align 8
  %x17 = load i32, i32* %7, align 4
  %y18 = load i32, i32* %9, align 4
  %17 = sub i32 %x17, %y18
  %zero19 = load i32, i32* %5, align 4
  %18 = call { i8*, i8* }* %build_term.0(i32 %17, i32 %zero19)
  %malloccall20 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons221 = bitcast i8* %malloccall20 to { i8*, i8* }*
  %Data_p22 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons221, i32 0, i32 0
  %Next_p23 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons221, i32 0, i32 1
  %Data_c24 = bitcast i8** %Data_p22 to i32**
  %malloccall25 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr26 = bitcast i8* %malloccall25 to i32*
  store i32 %lead_coeff, i32* %D_ptr26, align 4
  store i32* %D_ptr26, i32** %Data_c24, align 8
  %Next_c27 = bitcast i8** %Next_p23 to { i8*, i8* }**
  store { i8*, i8* }* %18, { i8*, i8* }** %Next_c27, align 8
  store { i8*, i8* }* %Cons221, { i8*, i8* }** %16, align 8
  %19 = alloca { i8*, i8* }*, align 8
  %f.21 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @f.21, align 8
  %xs28 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %poly_times.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_times.0, align 8
  %lead_term = load { i8*, i8* }*, { i8*, i8* }** %16, align 8
  %ys29 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %zero30 = load i32, i32* %5, align 4
  %20 = call { i8*, i8* }* %poly_times.0({ i8*, i8* }* %lead_term, { i8*, i8* }* %ys29, i32 %zero30)
  %zero31 = load i32, i32* %5, align 4
  %21 = call { i8*, i8* }* %f.21({ i8*, i8* }* %xs28, { i8*, i8* }* %20, i32 %zero31)
  store { i8*, i8* }* %21, { i8*, i8* }** %19, align 8
  %poly_mod.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_mod.0, align 8
  %diff = load { i8*, i8* }*, { i8*, i8* }** %19, align 8
  %ys32 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %zero33 = load i32, i32* %5, align 4
  %22 = call { i8*, i8* }* %poly_mod.0({ i8*, i8* }* %diff, { i8*, i8* }* %ys32, i32 %zero33)
  br label %ifcont

ifcont:                                           ; preds = %else8, %then6
  %iftmp = phi { i8*, i8* }* [ %xs7, %then6 ], [ %22, %else8 ]
  br label %ifcont34

ifcont34:                                         ; preds = %ifcont, %then
  %iftmp35 = phi { i8*, i8* }* [ %xs, %then ], [ %iftmp, %ifcont ]
  ret { i8*, i8* }* %iftmp35
}

define i32 @f.20.fun(i32 %0, i32 %1) {
entry:
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = alloca i32, align 4
  store i32 %1, i32* %3, align 4
  %times = load i32 (i32, i32)*, i32 (i32, i32)** @times, align 8
  %x = load i32, i32* %2, align 4
  %inv = load i32 (i32)*, i32 (i32)** @inv, align 8
  %y = load i32, i32* %3, align 4
  %4 = call i32 %inv(i32 %y)
  %5 = call i32 %times(i32 %x, i32 %4)
  ret i32 %5
}

define { i8*, i8* }* @f.21.fun({ i8*, i8* }* %0, { i8*, i8* }* %1, i32 %2) {
entry:
  %3 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %3, align 8
  %4 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %1, { i8*, i8* }** %4, align 8
  %5 = alloca i32, align 4
  store i32 %2, i32* %5, align 4
  %poly_plus.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_plus.0, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %poly_neg.0 = load { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*)** @poly_neg.0, align 8
  %ys = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %6 = call { i8*, i8* }* %poly_neg.0({ i8*, i8* }* %ys)
  %zero = load i32, i32* %5, align 4
  %7 = call { i8*, i8* }* %poly_plus.0({ i8*, i8* }* %xs, { i8*, i8* }* %6, i32 %zero)
  ret { i8*, i8* }* %7
}

define { i8*, i8* }* @poly_gcd.0.fun({ i8*, i8* }* %0, { i8*, i8* }* %1, i32 %2) {
entry:
  %3 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %3, align 8
  %4 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %1, { i8*, i8* }** %4, align 8
  %5 = alloca i32, align 4
  store i32 %2, i32* %5, align 4
  %poly_equals.0 = load i1 ({ i8*, i8* }*, { i8*, i8* }*)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)** @poly_equals.0, align 8
  %ys = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %zero = load i32, i32* %5, align 4
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons2 = bitcast i8* %malloccall to { i8*, i8* }*
  %Data_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 0
  %Next_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 1
  %Data_c = bitcast i8** %Data_p to i32**
  %malloccall1 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr = bitcast i8* %malloccall1 to i32*
  store i32 %zero, i32* %D_ptr, align 4
  store i32* %D_ptr, i32** %Data_c, align 8
  %Next_c = bitcast i8** %Next_p to { i8*, i8* }**
  store { i8*, i8* }* null, { i8*, i8* }** %Next_c, align 8
  %6 = call i1 %poly_equals.0({ i8*, i8* }* %ys, { i8*, i8* }* %Cons2)
  br i1 %6, label %then, label %else

then:                                             ; preds = %entry
  %xs = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  br label %ifcont

else:                                             ; preds = %entry
  %7 = alloca { i8*, i8* }*, align 8
  %poly_mod.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_mod.0, align 8
  %xs2 = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %ys3 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %zero4 = load i32, i32* %5, align 4
  %8 = call { i8*, i8* }* %poly_mod.0({ i8*, i8* }* %xs2, { i8*, i8* }* %ys3, i32 %zero4)
  store { i8*, i8* }* %8, { i8*, i8* }** %7, align 8
  %poly_gcd.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_gcd.0, align 8
  %ys5 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %rem = load { i8*, i8* }*, { i8*, i8* }** %7, align 8
  %zero6 = load i32, i32* %5, align 4
  %9 = call { i8*, i8* }* %poly_gcd.0({ i8*, i8* }* %ys5, { i8*, i8* }* %rem, i32 %zero6)
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  %iftmp = phi { i8*, i8* }* [ %xs, %then ], [ %9, %else ]
  ret { i8*, i8* }* %iftmp
}

define i32 @f.24.fun(i32 %0, i32 %1) {
entry:
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = alloca i32, align 4
  store i32 %1, i32* %3, align 4
  %pl = load i32 (i32, i32)*, i32 (i32, i32)** @pl, align 8
  %x = load i32, i32* %2, align 4
  %neg = load i32 (i32)*, i32 (i32)** @neg, align 8
  %y = load i32, i32* %3, align 4
  %4 = call i32 %neg(i32 %y)
  %5 = call i32 %pl(i32 %x, i32 %4)
  ret i32 %5
}

define i32 @f.25.fun(i32 %0, i32 %1) {
entry:
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = alloca i32, align 4
  store i32 %1, i32* %3, align 4
  %times = load i32 (i32, i32)*, i32 (i32, i32)** @times, align 8
  %x = load i32, i32* %2, align 4
  %inv = load i32 (i32)*, i32 (i32)** @inv, align 8
  %y = load i32, i32* %3, align 4
  %4 = call i32 %inv(i32 %y)
  %5 = call i32 %times(i32 %x, i32 %4)
  ret i32 %5
}

define { i8*, i8* }* @f.26.fun({ i8*, i8* }* %0) {
entry:
  %1 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %1, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %1, align 8
  ret { i8*, i8* }* %xs
}

define { i8*, i8* }* @f.27.fun({ i8*, i8* }* %0, { i8*, i8* }* %1, i32 %2) {
entry:
  %3 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %0, { i8*, i8* }** %3, align 8
  %4 = alloca { i8*, i8* }*, align 8
  store { i8*, i8* }* %1, { i8*, i8* }** %4, align 8
  %5 = alloca i32, align 4
  store i32 %2, i32* %5, align 4
  %poly_plus.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_plus.0, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %3, align 8
  %poly_neg.0 = load { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*)** @poly_neg.0, align 8
  %ys = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %6 = call { i8*, i8* }* %poly_neg.0({ i8*, i8* }* %ys)
  %zero = load i32, i32* %5, align 4
  %7 = call { i8*, i8* }* %poly_plus.0({ i8*, i8* }* %xs, { i8*, i8* }* %6, i32 %zero)
  ret { i8*, i8* }* %7
}

define i32 @main() {
entry:
  %0 = alloca { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, align 8
  %malloccall = tail call i8* @malloc(i32 ptrtoint ({ i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* getelementptr ({ i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* null, i32 1) to i32))
  %field = bitcast i8* %malloccall to { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }*
  %field.poly_gcd = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 20
  %poly_gcd.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_gcd.0, align 8
  store { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* %poly_gcd.0, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** %field.poly_gcd, align 8
  %field.poly_mod = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 19
  %poly_mod.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_mod.0, align 8
  store { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* %poly_mod.0, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** %field.poly_mod, align 8
  %field.poly_div = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 18
  %poly_div.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_div.0, align 8
  store { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* %poly_div.0, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** %field.poly_div, align 8
  %field.poly_times = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 17
  %poly_times.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_times.0, align 8
  store { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* %poly_times.0, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** %field.poly_times, align 8
  %field.poly_neg = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 16
  %poly_neg.0 = load { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*)** @poly_neg.0, align 8
  store { i8*, i8* }* ({ i8*, i8* }*)* %poly_neg.0, { i8*, i8* }* ({ i8*, i8* }*)** %field.poly_neg, align 8
  %field.poly_minus = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 15
  %f.27 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @f.27, align 8
  store { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* %f.27, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** %field.poly_minus, align 8
  %field.poly_plus = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 14
  %poly_plus.0 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** @poly_plus.0, align 8
  store { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* %poly_plus.0, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** %field.poly_plus, align 8
  %field.poly_eval = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 13
  %poly_eval.0 = load i32 ({ i8*, i8* }*, i32)*, i32 ({ i8*, i8* }*, i32)** @poly_eval.0, align 8
  store i32 ({ i8*, i8* }*, i32)* %poly_eval.0, i1 ({ i8*, i8* }*, { i8*, i8* }*)** %field.poly_eval, align 8
  %field.poly_equals = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 12
  %poly_equals.0 = load i1 ({ i8*, i8* }*, { i8*, i8* }*)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)** @poly_equals.0, align 8
  store i1 ({ i8*, i8* }*, { i8*, i8* }*)* %poly_equals.0, i32 ({ i8*, i8* }*, i32)** %field.poly_equals, align 8
  %field.poly_deg = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 11
  %poly_deg.0 = load i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)** @poly_deg.0, align 8
  store i32 ({ i8*, i8* }*)* %poly_deg.0, i32 ({ i8*, i8* }*)** %field.poly_deg, align 8
  %field.make_poly = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 10
  %f.26 = load { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*)** @f.26, align 8
  store { i8*, i8* }* ({ i8*, i8* }*)* %f.26, { i8*, i8* }* ({ i8*, i8* }*)** %field.make_poly, align 8
  %field.pow = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 9
  %pow.0 = load i32 (i32, i32)*, i32 (i32, i32)** @pow.0, align 8
  store i32 (i32, i32)* %pow.0, i32 (i32, i32)** %field.pow, align 8
  %field.div = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 8
  %f.25 = load i32 (i32, i32)*, i32 (i32, i32)** @f.25, align 8
  store i32 (i32, i32)* %f.25, i32 (i32, i32)** %field.div, align 8
  %field.inv = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 7
  %inv = load i32 (i32)*, i32 (i32)** @inv, align 8
  store i32 (i32)* %inv, i32 (i32)** %field.inv, align 8
  %field.times = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 6
  %times = load i32 (i32, i32)*, i32 (i32, i32)** @times, align 8
  store i32 (i32, i32)* %times, i32 (i32, i32)** %field.times, align 8
  %field.one = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 5
  store i32 1, i32* %field.one, align 4
  %field.minus = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 4
  %f.24 = load i32 (i32, i32)*, i32 (i32, i32)** @f.24, align 8
  store i32 (i32, i32)* %f.24, i32 (i32, i32)** %field.minus, align 8
  %field.neg = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 3
  %neg = load i32 (i32)*, i32 (i32)** @neg, align 8
  store i32 (i32)* %neg, i32 (i32)** %field.neg, align 8
  %field.plus = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 2
  %pl = load i32 (i32, i32)*, i32 (i32, i32)** @pl, align 8
  store i32 (i32, i32)* %pl, i32 (i32, i32)** %field.plus, align 8
  %field.equals = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 1
  %eq = load i1 (i32, i32)*, i1 (i32, i32)** @eq, align 8
  store i1 (i32, i32)* %eq, i1 (i32, i32)** %field.equals, align 8
  %field.zero = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, i32 0, i32 0
  store i32 0, i32* %field.zero, align 4
  %1 = load { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %field, align 8
  store { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* } %1, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %0, align 8
  %2 = alloca { i8*, i8* }*, align 8
  %fd.make_poly = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %0, i32 0, i32 10
  %fd.make_poly1 = load { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*)** %fd.make_poly, align 8
  %malloccall2 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons2 = bitcast i8* %malloccall2 to { i8*, i8* }*
  %Data_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 0
  %Next_p = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons2, i32 0, i32 1
  %Data_c = bitcast i8** %Data_p to i32**
  %malloccall3 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr = bitcast i8* %malloccall3 to i32*
  store i32 1, i32* %D_ptr, align 4
  store i32* %D_ptr, i32** %Data_c, align 8
  %Next_c = bitcast i8** %Next_p to { i8*, i8* }**
  store { i8*, i8* }* null, { i8*, i8* }** %Next_c, align 8
  %malloccall4 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons25 = bitcast i8* %malloccall4 to { i8*, i8* }*
  %Data_p6 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons25, i32 0, i32 0
  %Next_p7 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons25, i32 0, i32 1
  %Data_c8 = bitcast i8** %Data_p6 to i32**
  %malloccall9 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr10 = bitcast i8* %malloccall9 to i32*
  store i32 0, i32* %D_ptr10, align 4
  store i32* %D_ptr10, i32** %Data_c8, align 8
  %Next_c11 = bitcast i8** %Next_p7 to { i8*, i8* }**
  store { i8*, i8* }* %Cons2, { i8*, i8* }** %Next_c11, align 8
  %malloccall12 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons213 = bitcast i8* %malloccall12 to { i8*, i8* }*
  %Data_p14 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons213, i32 0, i32 0
  %Next_p15 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons213, i32 0, i32 1
  %Data_c16 = bitcast i8** %Data_p14 to i32**
  %malloccall17 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr18 = bitcast i8* %malloccall17 to i32*
  store i32 2, i32* %D_ptr18, align 4
  store i32* %D_ptr18, i32** %Data_c16, align 8
  %Next_c19 = bitcast i8** %Next_p15 to { i8*, i8* }**
  store { i8*, i8* }* %Cons25, { i8*, i8* }** %Next_c19, align 8
  %malloccall20 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons221 = bitcast i8* %malloccall20 to { i8*, i8* }*
  %Data_p22 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons221, i32 0, i32 0
  %Next_p23 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons221, i32 0, i32 1
  %Data_c24 = bitcast i8** %Data_p22 to i32**
  %malloccall25 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr26 = bitcast i8* %malloccall25 to i32*
  store i32 1, i32* %D_ptr26, align 4
  store i32* %D_ptr26, i32** %Data_c24, align 8
  %Next_c27 = bitcast i8** %Next_p23 to { i8*, i8* }**
  store { i8*, i8* }* %Cons213, { i8*, i8* }** %Next_c27, align 8
  %3 = call { i8*, i8* }* %fd.make_poly1({ i8*, i8* }* %Cons221)
  store { i8*, i8* }* %3, { i8*, i8* }** %2, align 8
  %4 = alloca { i8*, i8* }*, align 8
  %fd.make_poly28 = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %0, i32 0, i32 10
  %fd.make_poly29 = load { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*)** %fd.make_poly28, align 8
  %malloccall30 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons231 = bitcast i8* %malloccall30 to { i8*, i8* }*
  %Data_p32 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons231, i32 0, i32 0
  %Next_p33 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons231, i32 0, i32 1
  %Data_c34 = bitcast i8** %Data_p32 to i32**
  %malloccall35 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr36 = bitcast i8* %malloccall35 to i32*
  store i32 1, i32* %D_ptr36, align 4
  store i32* %D_ptr36, i32** %Data_c34, align 8
  %Next_c37 = bitcast i8** %Next_p33 to { i8*, i8* }**
  store { i8*, i8* }* null, { i8*, i8* }** %Next_c37, align 8
  %malloccall38 = tail call i8* @malloc(i32 ptrtoint ({ i8*, i8* }* getelementptr ({ i8*, i8* }, { i8*, i8* }* null, i32 1) to i32))
  %Cons239 = bitcast i8* %malloccall38 to { i8*, i8* }*
  %Data_p40 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons239, i32 0, i32 0
  %Next_p41 = getelementptr inbounds { i8*, i8* }, { i8*, i8* }* %Cons239, i32 0, i32 1
  %Data_c42 = bitcast i8** %Data_p40 to i32**
  %malloccall43 = tail call i8* @malloc(i32 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i32))
  %D_ptr44 = bitcast i8* %malloccall43 to i32*
  store i32 1, i32* %D_ptr44, align 4
  store i32* %D_ptr44, i32** %Data_c42, align 8
  %Next_c45 = bitcast i8** %Next_p41 to { i8*, i8* }**
  store { i8*, i8* }* %Cons231, { i8*, i8* }** %Next_c45, align 8
  %5 = call { i8*, i8* }* %fd.make_poly29({ i8*, i8* }* %Cons239)
  store { i8*, i8* }* %5, { i8*, i8* }** %4, align 8
  %6 = alloca { i8*, i8* }*, align 8
  %fd.poly_div = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %0, i32 0, i32 18
  %fd.poly_div46 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** %fd.poly_div, align 8
  %xs = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %ys = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %fd.zero = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %0, i32 0, i32 0
  %fd.zero47 = load i32, i32* %fd.zero, align 4
  %7 = call { i8*, i8* }* %fd.poly_div46({ i8*, i8* }* %xs, { i8*, i8* }* %ys, i32 %fd.zero47)
  store { i8*, i8* }* %7, { i8*, i8* }** %6, align 8
  %8 = alloca { i8*, i8* }*, align 8
  %fd.poly_mod = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %0, i32 0, i32 19
  %fd.poly_mod48 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** %fd.poly_mod, align 8
  %xs49 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %ys50 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %fd.zero51 = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %0, i32 0, i32 0
  %fd.zero52 = load i32, i32* %fd.zero51, align 4
  %9 = call { i8*, i8* }* %fd.poly_mod48({ i8*, i8* }* %xs49, { i8*, i8* }* %ys50, i32 %fd.zero52)
  store { i8*, i8* }* %9, { i8*, i8* }** %8, align 8
  %10 = alloca { i8*, i8* }*, align 8
  %fd.poly_gcd = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %0, i32 0, i32 20
  %fd.poly_gcd53 = load { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)** %fd.poly_gcd, align 8
  %xs54 = load { i8*, i8* }*, { i8*, i8* }** %4, align 8
  %ys55 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %fd.zero56 = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %0, i32 0, i32 0
  %fd.zero57 = load i32, i32* %fd.zero56, align 4
  %11 = call { i8*, i8* }* %fd.poly_gcd53({ i8*, i8* }* %xs54, { i8*, i8* }* %ys55, i32 %fd.zero57)
  store { i8*, i8* }* %11, { i8*, i8* }** %10, align 8
  %fd.poly_eval = getelementptr inbounds { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }, { i32, i1 (i32, i32)*, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32, i32 (i32, i32)*, i32 (i32)*, i32 (i32, i32)*, i32 (i32, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*)*, i32 ({ i8*, i8* }*, i32)*, i1 ({ i8*, i8* }*, { i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)*, { i8*, i8* }* ({ i8*, i8* }*, { i8*, i8* }*, i32)* }* %0, i32 0, i32 12
  %fd.poly_eval58 = load i32 ({ i8*, i8* }*, i32)*, i32 ({ i8*, i8* }*, i32)** %fd.poly_eval, align 8
  %ys59 = load { i8*, i8* }*, { i8*, i8* }** %2, align 8
  %12 = call i32 %fd.poly_eval58({ i8*, i8* }* %ys59, i32 2)
  %printf = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @fmt, i32 0, i32 0), i32 %12)
  ret i32 0
}

declare noalias i8* @malloc(i32)
